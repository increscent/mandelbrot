<!doctype html>

<html>
	<head>
		<meta charset="utf-8"/>
	</head>

	<body style="margin: 0; padding: 0;">
		<canvas id="canvas" width="800" height="800"></canvas>

		<script type="text/javascript">
			var n_workers = 8;
			var worker_pool = [];
			for (var i = 0; i < n_workers; i++) {
				worker_pool[i] = new Worker('mandelbrot-worker.js');
			}
			var zooming = false;
			var zoom_count = 0;

			var canvas = document.getElementById('canvas');
			width = canvas.width;
			height = canvas.height;

			var initial_granularity = 200;
			var x_min = -1 * (width / initial_granularity / 2);
			var x_max = (width / initial_granularity / 2);
			var y_min = -1 * (height / initial_granularity / 2);
			var y_max = (height / initial_granularity / 2);

			var initial_zoom_ratio = .15;

			var max_iterations = 300;

			var context = canvas.getContext('2d');

			drawMandelbrot();

			canvas.onwheel = (e) =>  {
				if (e.deltaY == 0)
					return;

				if (zooming) {
					zoom_count++;
					return;
				} else {
					zooming = true;
				}

				var zoom_ratio = initial_zoom_ratio;/* + .001 * Math.pow(zoom_count, zoom_count);*/
				var x_zoom_margin = zoom_ratio * width;
				var y_zoom_margin = zoom_ratio * height;

				var zoom_direction = e.deltaY > 0 ? 1 : -1;

				var x_range = x_max - x_min;
				var y_range = y_max - y_min;

				var x_zoom = (x_zoom_margin / width) * x_range;
				var y_zoom = (y_zoom_margin / height) * y_range;

				var x_zoom_ratio = e.clientX / width;
				var y_zoom_ratio = e.clientY / height;

				x_min += (zoom_direction * x_zoom * x_zoom_ratio);
				x_max -= (zoom_direction * x_zoom * (1 - x_zoom_ratio));
				y_min += (zoom_direction * y_zoom * (1 - y_zoom_ratio));
				y_max -= (zoom_direction * y_zoom * y_zoom_ratio);

				drawMandelbrot().then(() => {
					zooming = false;
					zoom_count--;
				});
			};

			function drawMandelbrot() {
				return new Promise((resolve) => {
					var promises = [];
					for (var i = 0; i < n_workers; i++) {
						promises.push(render_part(i));
					}

					Promise.all(promises)
					.then(values => {
						var imageData = context.getImageData(0, 0, width, height);
						values.forEach(x => {
							for (var i = 3; i < x[0].length; i += 4) {
								imageData.data[i + x[1] * x[0].length] = x[0][i];
							}
						});
						context.putImageData(imageData, 0, 0);
						resolve();
					});
				});
			}

			function render_part(i) {
				return new Promise((resolve) => {
					worker_pool[i].onmessage = (e) => {
						resolve([e.data, i])
					};
					worker_pool[i].postMessage({
						width,
						height: height / n_workers,
						x_min,
						x_max,
						y_min: y_max - ((y_max - y_min) / n_workers * (i + 1)),
						y_max: y_max - ((y_max - y_min) / n_workers * i),
						max_iterations
					});
				});
			}
		</script>
	</body>
</html>